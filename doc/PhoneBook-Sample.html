<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<link type="text/css" rel="stylesheet" href="bootstrap.min.css" />
<title>DOCUMENTS</title>
</head>

<body>

<ul>
	<li>Entities</li>
	<li>DbContext</li>
	<li>Database Migrations</li>
	<li>Application Services</li>
	<li>Testing Application Service From Javascript</li>
	<li>Menu definition</li>
	<li>Angular route</li>
</ul>

<h3>Introduction</h3>

<p>In this document, we will create a sample phonebook application based on 
ASP.NET Zero. This application will have authentication, authorization and 
setings.</p>
<p>We're creating and downloading the solution as described in
<a href="Getting-Started.html">Getting Started</a> document. After opening 
solution in Visual Studio, we see six projects:</p>
<p>

<img class="img-thumbnail" alt="Solution Overall" height="166" src="images/solution-overall.png" width="249" /></p>
<p>

<strong>TODO: Make application multi-tenant!!!</strong></p>

<h3>Entities</h3>
<p>Since Entities a part of domain (business) layer, we're creating them in the 
<strong>.Core</strong> project. In this Phone Book application, we have two fundamental entities, <strong>
Person</strong> and <strong>Phone</strong>.</p>
<p><strong>Person</strong> entity is shown below:</p>
<pre lang="cs">[Table(&quot;PbPersons&quot;)]
public class Person : FullAuditedEntity
{
    [Required]
    [MaxLength(32)]
    public virtual string Name { get; set; }

    [Required]
    [MaxLength(32)]
    public virtual string Surname { get; set; }

    public virtual string EmailAddress { get; set; }

    public virtual ICollection&lt;Phone&gt; Phones { get; set; }
}</pre>
<p><strong>Person</strong> is derived from FullAuditedEntity. It's primary key 
type is int (as default). <strong>FullAuditedEntity</strong> 
contains <strong>creation</strong>, <strong>modification </strong>and <strong>
deletion </strong>audit properties. It's also <strong>soft-delete</strong>. When 
we delete a person, it's not deleted by database but marked as deteled. See
<a href="http://www.aspnetboilerplate.com/Pages/Documents/Entities">entity</a> 
and <a href="http://www.aspnetboilerplate.com/Pages/Documents/Data-Filters">data 
filters</a> documentations for more information.</p>
<p>A Person can have zero or more phones (Phones is a navigation property). A phone is represented by <strong>
Phone</strong> entitiy:</p>

<pre lang="cs">[Table(&quot;PbPhones&quot;)]
public class Phone : CreationAuditedEntity&lt;long&gt;
{
    [ForeignKey(&quot;PersonId&quot;)]
    public virtual Person Person { get; set; }
    public virtual int PersonId { get; set; }

    [Required]
    public virtual PhoneType Type { get; set; }

    [Required]
    [MaxLength(16)]
    public virtual string Number { get; set; }
}</pre>
<p><strong>Phone</strong> entity's primary key is <strong>long </strong>(as 
declared) and it's <strong>creation audited</strong>. But it's not soft-delete, 
thus it's deleted from database when we delete a phone.</p>
<p>Lastly, there is a <strong>PhoneType</strong> enumeration as shown below:</p>
<pre lang="cs">public enum PhoneType : byte
{
    Mobile,
    Home,
    Business,
}</pre>
<h3>DbContext</h3>
<p>We add a DbSet property for each entity to <strong>PhoneBookDbContext</strong> 
class defined in <strong>.EntityFramework</strong> project.</p>

<pre lang="cs">public class PhoneBookDbContext : AbpZeroDbContext&lt;Tenant, Role, User&gt;
{
<strong>    public virtual IDbSet&lt;Person&gt; Persons { get; set; }
        
    public virtual IDbSet&lt;Phone&gt; Phones { get; set; }</strong>
        
    public virtual IDbSet&lt;BinaryObject&gt; BinaryObjects { get; set; }

    public PhoneBookDbContext()
        : base(&quot;Default&quot;)
    {

    }
    
    //...other codes
}</pre>
<p>We added <strong>Persons </strong>and <strong>Phones </strong>properties 
(others are coming ready when we create project).</p>

<h3>Database Migrations</h3>
<p>We use <strong>EntityFramework Code-First migrations</strong> to migrate 
database schema. Since we added two entities, our DbContext is changed. So, we 
should create a <strong>new migration</strong> to create needed tables in the 
database.</p>
<p>After opening <strong>Package Manager Console</strong> and selecting <strong>
.EntityFramework</strong> as <strong>default project</strong>, we write the 
following command:</p>
<p>
<img alt="Entity Framework Code First Migration" height="97" src="images/phonebook-migrations-1.png" width="597" /></p>
<p>This command will add a migration class as shown below:</p>

<pre lang="cs">public partial class Added_Person_And_Phone : DbMigration
{
    public override void Up()
    {
        CreateTable(
            &quot;dbo.PbPersons&quot;,
            c =&gt; new
                {
                    Id = c.Int(nullable: false, identity: true),
                    Name = c.String(nullable: false, maxLength: 32),
                    Surname = c.String(nullable: false, maxLength: 32),
                    EmailAddress = c.String(),
                    IsDeleted = c.Boolean(nullable: false),
                    DeleterUserId = c.Long(),
                    DeletionTime = c.DateTime(),
                    LastModificationTime = c.DateTime(),
                    LastModifierUserId = c.Long(),
                    CreationTime = c.DateTime(nullable: false),
                    CreatorUserId = c.Long(),
                },
            annotations: new Dictionary&lt;string, object&gt;
            {
                { &quot;DynamicFilter_Person_SoftDelete&quot;, &quot;EntityFramework.DynamicFilters.DynamicFilterDefinition&quot; },
            })
            .PrimaryKey(t =&gt; t.Id);
            
        CreateTable(
            &quot;dbo.PbPhones&quot;,
            c =&gt; new
                {
                    Id = c.Long(nullable: false, identity: true),
                    PersonId = c.Int(nullable: false),
                    Type = c.Byte(nullable: false),
                    Number = c.String(nullable: false, maxLength: 16),
                    CreationTime = c.DateTime(nullable: false),
                    CreatorUserId = c.Long(),
                })
            .PrimaryKey(t =&gt; t.Id)
            .ForeignKey(&quot;dbo.PbPersons&quot;, t =&gt; t.PersonId, cascadeDelete: true)
            .Index(t =&gt; t.PersonId);
            
    }
        
    public override void Down()
    {
        DropForeignKey(&quot;dbo.PbPhones&quot;, &quot;PersonId&quot;, &quot;dbo.PbPersons&quot;);
        DropIndex(&quot;dbo.PbPhones&quot;, new[] { &quot;PersonId&quot; });
        DropTable(&quot;dbo.PbPhones&quot;);
        DropTable(&quot;dbo.PbPersons&quot;,
            removedAnnotations: new Dictionary&lt;string, object&gt;
            {
                { &quot;DynamicFilter_Person_SoftDelete&quot;, &quot;EntityFramework.DynamicFilters.DynamicFilterDefinition&quot; },
            });
    }
}</pre>
<p>We don't have to know so much about format and rules of this file. But, it's 
suggested to have a basic understanding of migrations. In the same Package 
Manager Console, we write "<strong>Update-Database</strong>" command in order to 
apply the new migration to database. After updating , we can see that new tables 
(PbPersons and PbPhones) added to the database.</p>
<p>
<img alt="PhoneBook tables" height="311" src="images/phonebook-tables.png" width="206" /></p>
<p>But these new tables are empty. We can use EntityFramework's <strong>Seed</strong> 
method to add some initial data to database. In ASP.NET Zero, there are some 
classes to fill initial data for users and settings:</p>
<p>
<img alt="Entity Framework seed data" height="119" src="images/phonebook-seed-files.png" width="283" /></p>
<p>So, we can add a seperated class to fill some people and phones to database 
as shown below:</p>
<pre lang="cs">public class InitialPeopleAndPhoneCreator
{
    private readonly PhoneBookDbContext _context;

    public InitialPeopleAndPhoneCreator(PhoneBookDbContext context)
    {
        _context = context;
    }

    public void Create()
    {
        var douglas = _context.Persons.FirstOrDefault(p =&gt; p.EmailAddress == &quot;douglas.adams@fortytwo.net&quot;);
        if (douglas == null)
        {
            _context.Persons.Add(
                new Person
                {
                    Name = &quot;Douglas&quot;,
                    Surname = &quot;Adams&quot;,
                    EmailAddress = &quot;douglas.adams@fortytwo.com&quot;,
                    Phones = new List&lt;Phone&gt;
                                {
                                    new Phone {Type = PhoneType.Home, Number = &quot;1112242&quot;},
                                    new Phone {Type = PhoneType.Home, Number = &quot;2223342&quot;}
                                }
                });
        }

        var asimov = _context.Persons.FirstOrDefault(p =&gt; p.EmailAddress == &quot;isaac.asimov@foundation.org&quot;);
        if (asimov == null)
        {
            _context.Persons.Add(
                new Person
                {
                    Name = &quot;Isaac&quot;,
                    Surname = &quot;Asimov&quot;,
                    EmailAddress = &quot;isaac.asimov@foundation.org&quot;,
                    Phones = new List&lt;Phone&gt;
                                {
                                    new Phone {Type = PhoneType.Home, Number = &quot;8889977&quot;}
                                }
                });
        }
    }
}</pre>
<p>These type of default data is good since we can also use these data in unit 
tests. Surely, we should be careful about seed data since this code will always 
be executed after each <strong>Update-Database</strong> command (See EntityFramework 
documentations to know more about seed data). This class is created and called 
in <strong>InitialDbBuilder</strong> class, and it's called from 
EntityFramework's <strong>Configuration</strong> class. This is not so 
important, just for a good code organization.</p>
<p>We are executing Testing Application Service From Javascript command to run 
migration &amp; seed again.</p>
<h3>Application Services</h3>
<p>Next layer is the application layer. We're creating an application service to 
get and manipulate peoples and phones. Application services are located in
<strong>.Application</strong> project. We're creating an interface to define 
the person application service:</p>
<pre lang="cs">public interface IPersonAppService : IApplicationService
{
    ListResultOutput&lt;PersonListDto&gt; GetPeople(GetPeopleInput input);
}</pre>
<p>An application service method gets/returns DTOs. ListResultOutput is a 
pre-build DTO to return a list of another DTO. GetPeopleInput is a DTO to pass 
request parameters to getPeople method. So, GetPeopleIntput and PersonListDto 
are defined as shown below:</p>

<pre lang="cs">public class GetPeopleInput : IInputDto
{
    public string Filter { get; set; }
}

[AutoMapFrom(typeof(Person))]
public class PersonListDto : FullAuditedEntityDto
{
    public virtual string Name { get; set; }

    public virtual string Surname { get; set; }

    public virtual string EmailAddress { get; set; }
}</pre>
<p>Implementing IInputDto is a convention in ABP. It provides automatic 
validation. AutoMapFrom is used to configure AutoMapper to create mapping from 
Person to PersonListDto. FullAuditedEntityDto used to inherit audit properties 
automatically. See
<a href="http://www.aspnetboilerplate.com/Pages/Documents/Application-Services">
application service</a> and
<a href="http://www.aspnetboilerplate.com/Pages/Documents/Data-Transfer-Objects">
DTO</a> documentations for more informations.</p>
<p>After defining interface, we can implement it as shown below:</p>
<pre lang="cs">public class PersonAppService : PhoneBookAppServiceBase, IPersonAppService
{
    private readonly IRepository&lt;Person&gt; _personRepository;

    public PersonAppService(IRepository&lt;Person&gt; personRepository)
    {
        _personRepository = personRepository;
    }

    public ListResultOutput&lt;PersonListDto&gt; GetPeople(GetPeopleInput input)
    {
        var persons = _personRepository
            .GetAll()
            .WhereIf(
                !input.Filter.IsNullOrEmpty(),
                p =&gt; p.Name.Contains(input.Filter) ||
                        p.Surname.Contains(input.Filter) ||
                        p.EmailAddress.Contains(input.Filter)
            )
            .OrderBy(p =&gt; p.Name)
            .ThenBy(p =&gt; p.Surname)
            .ToList();

        return new ListResultOutput&lt;PersonListDto&gt;(persons.MapTo&lt;List&lt;PersonListDto&gt;&gt;());
    }
}</pre>
<p>We're injecting <strong>person repository</strong> (it's automatically created by ABP) and 
using it to filter and get peoples from database. <strong>WhereIf</strong> is an extension method 
here. It performs Where only if filter is not null or empty (ABP has similar 
shortcut extension methods). Lastly, <strong>MapTo</strong> method automatically 
converts Person entities to PersonListDto entities using AutoMapper library.</p>
<h3>Testing Application Service From Javascript</h3>
<p>&nbsp;</p>
<h3>Menu Definition</h3>
<p>It's time to touch UI. First, we are adding a new menu item called "People" 
to <strong>AppNavigationProvider</strong> class:</p>
<pre lang="cs">new MenuItemDefinition(
    PageNames.App.Tenant.People,
    L("People"),
    url: "people",
    icon: "glyphicon glyphicons-group"
)</pre>
<p>First parameter is a string constant "People". It's an arbitrary unique name 
to identify this menu item. L("People") is localized name of the menu. url is 
the AngularJs route (state) and icon is shown menu icon. For this definition, we 
should add "People" to localization files (PhoneBook.xml for English, 
PhoneBook-tr.xml for Turkish localization). Example line:</p>
<pre lang="xml">&lt;text name=&quot;People&quot; value=&quot;People&quot; /&gt;</pre>
<h3>Angular Route</h3>
<p>Menu definition automatically shown in the main menu but we should also 
create a routing.</p>

</body>

</html>
